
<Transaction>

파일 저장이 아닌 DB에 저장하는 이유 : DB는 트랜잭션을 지원하기 때문이다.
트랜잭션 : 데이터베이스에서 작업의 기본 단위

ex) 5000원 거래 : A의 잔고를 5000원 감소, B의 잔고를 5000원 증가 
=> 두 가지 작업으로 이루어져 있다. 이 둘은 하나의 작업처럼 동작해야 한다. 

- Commit : 모든 작업이 성공하여 데이터베이스에 정상 반영
- Rollback : 작업 중 실패 요소가 있어 작업 시작 이전으로 되돌리는 동작

트랜잭션 ACID 
Atomicity 원자성 : 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 모두 성공하거나 실패해야 한다.
Consistency 일관성 : 모든 트랜잭션은 일관성 있는 상태를 유지해야 한다.
Isolation 격리성 : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
Duratibility 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.

- 격리성을 완벽히 보장하기 위해서는 트랜잭션을 거의 순서대로 실행해야 한다.
=> 동시 처리 성능이 나빠진다. => ANSI 표준 : 트랜잭션의 격리 수준을 네 단계로 나누어 정의
Isolation level
1) READ UNCOMMITED 커밋되지 않은 상태로 읽기
2) READ COMMITTED 커밋된 상태에서 읽기
3) REPEATABLE READ 반복 가능한 읽기
4) SERIALIZABLE 직렬화 가능


-------------------------------------------------------------------------------------------------------------------------------------

<DB Session>

데이터베이스 연결 구조
1) 사용자의 DB 접근 : WAS, DB 접근 툴 등을 이용하여 DB 서버에 접근, 연결을 요청하여 커넥션을 맺는다.
2) DB 서버는 내부에 세션을 생성, 연결된 현재 커넥션을 통한 모든 요청은 이 세션을 이용해 실행한다.
3) 사용자가 커넥션을 닫거나 DBA가 세션 강제 종료 시 세션이 종료된다.

Session
- 클라이언트가 SQL을 커넥션을 통해 전달 시 SQL을 받아 실행하는 역할
- 트랜잭션 시작의 주체, Commit, Rollback을 통해 트랜잭션을 종료한다.
- 세션은 커넥션의 수만큼 만들어진다. 커넥션 풀에 커넥션이 n개 존재할 경우 세션도 n개 생성된다.

commit 관련 SQL
set autocommit true; : 자동 커밋, 설정하지 않으면 기본값으로 자동 커밋이 이루어진다.
쿼리를 하나 실행한 직후 자동으로 매번 커밋을 호출한다. 커밋, 롤백을 직접 호출하지 않아도 되지만 매번 자동으로 쿼리 한 단위씩 커밋이 되기 때문에 트랜잭션 기능을 이용하지 못한다.
set autocommit false; : 수동 커밋, '트랜잭션을 시작하다'와 같은 의미이다. 트랜잭션 끝에 commit이나 rollback을 써야 한다.

트랜잭션 예시
set autocommit false; //트랜잭션 시작
insert into member(member_id, money) values ('data3', 10000);
insert into member(member_id, money) values ('data4', 10000);
commit //트랜잭션 종료




-------------------------------------------------------------------------------------------------------------------------------------
Transaction 사용
- 데이터를 변경하는 쿼리를 실행하고 commit을 하지 않으면 해당 데이터는 '임시로' 저장된다.
- 해당 트랜잭션을 시작한 세션의 유저에게만 변경 데이터가 보여지고, 다른 세션 유저에게는 데이터 변경이 반영되지 않은 채로 보여진다. (변경 : 등록, 수정, 삭제)

ex 1) 
user 1의 테이블 수정, commit하지 않은 상태
user 2가 테이블을 조회하면 데이터가 변경되지 않은 채로 조회된다.
user 1의 commit이 이루어지면 user 2의 테이블 조회에도 데이터가 변경되어 조회된다.
user 1이 데이터를 수정 중 변경이 잘못 이루어지면 rollback을 사용해 변경 이전으로 되돌릴 수 있다.


ex 2)
SQL 트랜잭션 실습(H2 DB)
-case 1 : 계좌 이체 성공
-case 2 : 계좌 이체 실패 - commit
-case 3 : 계좌 이체 실패 - rollback

drop table member if exists cascade;
create table member(
                       member_id varchar(10),
                       money integer not null default 0,
                       primary key (member_id)
);


<case 1 : 계좌 이체 성공>

set autocommit true;
    delete from member;
    insert into member(member_id, money) values('memberA', 10000);
    insert into member(member_id, money) values('memberB', 10000);

select * from member; : user1, 2 모두 같은 결과창이 보여진다.

user 1 : 트랜잭션 시작
set autocommit fasle;
    update member set money=10000 - 2000 where member_id = 'memberA';
    update member set money=10000 + 2000 where member_id = 'memberB';


commit을 하지 않은 상태에서 
user 1의 select : update 쿼리가 적용된 결과가 보여진다. (임시 저장)
user 2의 select : update 쿼리가 적용되지 않은 기존의 결과가 보여진다.

user 1의 commit; 이후
user 1, 2는 둘 다 update 쿼리가 적용된 결과가 보여진다. 
(user 1, 2 = 세션 1, 2로 각각 접속했다고 가정)

<case 2 : 계좌 이체 실패 - commit>

user 1 : 트랜잭션 시작
set autocommit fasle;
    update member set money=10000 - 2000 where member_id = 'memberA';
    update member set money=10000 + 2000 where member_idd = 'memberB';

=> user 1이 쿼리 실행 시 오류가 난다. Column "Member_idd" not found; SQL statement

이 상태에서 강제로 commit; 호출 시에는 memberB의 계좌는 변동없이 memberA의 계좌에서 2000원만 줄어드는 문제가 발생한다.

<case 3 : 계좌 이체 실패 - rollback>
user 1 : 트랜잭션 시작
set autocommit fasle;
    update member set money=10000 - 2000 where member_id = 'memberA';
    update member set money=10000 + 2000 where member_idd = 'memberB';

=> user 1이 쿼리 실행 시 오류가 난다. Column "Member_idd" not found; SQL statement
이 상태에서 commit;하지 않고 rollback;을 수행하면 트랜잭션을 반영하지 않은 기존 데이터가 보여진다.



-------------------------------------------------------------------------------------------------------------------------------------

<DB Lock>
세션 1이 트랜잭션 시작, 데이터 수정하는 사이 세션 1이 커밋을 수행하지 않았는데,
세션 2에서 동시에 같은 데이터를 수정하게 되면 여러 문제가 발생한다. => Atomicity 원자성이 깨진다.
=> 세션이 트랜잭션 시작 이후 데이터를 수정하는 동안에는 commit이나 rollback이 호출되기 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 만들어야 한다.
데이터베이스는 해당 문제를 해결하기 위해 '락 Lock' 개념을 지원한다.

set autocommit true;
    delete from member;
    insert into member(member_id, money) values('memberA', 10000);

1: user 1은 memberA의 money를 10000에서 500으로 바꾸려 한다.
user 1(세션 1)의 Lock 접근 
=> memberA의 money 필드에 있는 Lock에 접근한다.

2: memberA의 money Lock을 user 1이 획득한다.
=> user 1은 memberA의 money를 변경시킬 권한을 얻는다.

3: user 1의 데이터 update
set autocommit false;
    update member set money=500 where member_id  = 'memberA';

//아직 커밋되지 않은 상태이다.


4: user 2의 memberA money 접근 
=> user 2가 memberA의 money에 접근하더라도 user 2는 Lock이 없기 때문에 접근 불가
//user 2는 Lock을 얻기 위해 60초동안 대기, 대기 중 Lock을 얻으면 트랜잭션을 실행한다.
set LOCK_TIMEOUT 60000;
    set autocommit false;
        update member set money = 1000 where member_id = 'memberA'

5: user 1의 Lock 반납
user 1은 commit;을 실행한다 : user 1은 memberA의 money에 대한 Lock을 반납한다. // memberA의 money = 500
user 2는 Lock을 얻기 위해 대기하다 Lock을 얻으면 이후 변경된(commit된) 데이터를 이용해 트랜잭션을 수행한다. //memberA의 money = 1000

6: user 2의 Lock 반납
트랜잭션을 종료한 user 2는 commit; 이후 Lock을 다시 반납한다.

=> 락 개념을 이용하여 원자성 문제 해결


<DB Lock - select 조회>
일반적으로 DB Lock은 데이터 변경 시에 사용한다. (등록, 수정, 삭제)
조회 select는 보통 락을 사용하지 않지만 조회 시에도 DB Lock 사용이 가능하다 : select ~ for update
=> select ... from ... where ... for update 

*중요한 데이터의 경우, 조회 도중 다른 세션이 데이터를 변경(등록, 수정, 삭제)하지 못하도록 막기 위해서 조회에서 Lock을 사용한다.
-select ... for update를 이용하면 조회 도중 Lock을 가지게 되기 때문에 다른 트랜잭션들이 접근하지 못한다.

select * from member where member_id = 'memberA' for update;

-------------------------------------------------------------------------------------------------------------------------------------
